{
  "hash": "8d82b4ade4dec46f666b514881a818af",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Optimal Stopping Problems\nauthor: Dean Marchiori\ndate: '2022-09-28'\ncategories: [R, statistics]\nimage: \"featured.png\"\n---\n\n\n\n\nThe August 2022 edition of Significance Magazine posts a challenge:\n\n>**Choosing a husband**: In the court of King Arthur, a damsel, Elfreda needs to choose\na husband. Each day for the next 100 days Knights will come to Calemlot to be \ninterviewed by Arthur to be Elfreda's husband. However once the Knights left the\ncastle they did not return. She needed to decide as soon as she saw a knight\nwhether to marry or pass. In the challenge, Elfreda is given the advice from Merlin \nto not pick any of the first 37, just look and decide who is best, then pick the next knight who is better than that. \n\nThe questions are: \n\n\n1. Why did Merlin instruct Elfreda to ignore the first 37 suitors?  \n\n2. What did Merlin think was the probability that Elfreda would choose the very best\nknight with this strategy?\n\n\nThis is a well known problem in Optimal Stopping theory. When you look at the first\nfew knights you have no information about how they rank relative to all 100. But\nby the time you have assessed most of the 100 knights you have information but\nyou have no agency. The knights have all moved on and you either miss out or have\nto settle for whoever is left.  \n\nThis problem comes up every time I look for a parking spot on a busy day. Do I take the first\nspot I find a long way from the beach? I could try to get a closer spot but may\nnot find one and could miss out entirely. Most likely the earlier spots are now\ntaken. \n\n**When is the optimal time to stop looking and take the leap?**  \n\nThe strategy here is:  \n\n1. Just *Look* at a given number of knights without commiting to any  \n2. Note the best ranking knight of out of the ones we looked at  \n3. Commit to the very next knight that is *better* than the best ranked so far.    \n\nWe assume we look at least one knight before stopping our search and assume that\nif we fail to find a superior knight after our *looking* period - we miss out!  We\nobviously wont settle for less. (I guess I could force this to accept the last one\nin line - not a big deal).  \n\n\n## Simulation in R  \n\nWe can simulate this problem by sampling 100 random knights and assigning them \na random ranking of 1-100 (assume 100 is best). \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(111)\nsample(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1]  78  84  83  47  25  59  69  35  72  26  49  45  74   8 100  96  24  48\n [19]  95   7  21  15   1   9  63  40  85  93  71  52  28  38  88  61  92  30\n [37]   5  53  37   6  36  41  70  42  18  27  29  23  32  89  86  57  16  90\n [55]  39   4  68  55  99  98  79  43  54  97  65  50  94  44  10  91  56  80\n [73]  19  73  33  11  12  67  81  62  76  60  77  34   2  20  13  51  14  64\n [91]  75  87  66  17  22   3  31  46  82  58\n```\n\n\n:::\n:::\n\n\n\nNext we can look at the cumulative maximum ranking. This will track the score of\nthe best knight seen so far. We also run, say, 10,000 simulations of this problem\nto analyse. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nset.seed(111)\nn <- 100\nsims <- 1e4\n\nknight_sims <- expand_grid(sim = 1:sims) |> \n  mutate(rankings = map(sim, ~sample(1:n))) |> \n  unnest(rankings) |> \n  group_by(sim) |> \n  mutate(stop_after_days = 1:n,\n         max_rank = cummax(rankings))\n\nknight_sims\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000,000 × 4\n# Groups:   sim [10,000]\n     sim rankings stop_after_days max_rank\n   <int>    <int>           <int>    <int>\n 1     1       78               1       78\n 2     1       84               2       84\n 3     1       83               3       84\n 4     1       47               4       84\n 5     1       25               5       84\n 6     1       59               6       84\n 7     1       69               7       84\n 8     1       35               8       84\n 9     1       72               9       84\n10     1       26              10       84\n# ℹ 999,990 more rows\n```\n\n\n:::\n:::\n\n\n\nWe can write a function that can map over each day and determine what rank\nknight we would end up with if we stopped searching after x days and committed to the \nnext best knight. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptimal_stop <- function(samp, i) {\n  if (i == 0) {\n    samp[1]\n  }\n  \n  if (i > length(samp) | i < 0) {\n    stop(\"Invalid choice\")\n  }\n  \n  if (any(samp > cummax(samp)[i]) == FALSE) {\n    # if you want to default to the last option\n    #samp[length(samp)]\n    \n    # if you would rather miss out if no superior choice\n    NA\n  } else{\n    idx <- which.max(samp > cummax(samp)[i])\n    samp[idx]\n  }\n}\n```\n:::\n\n\n\nWe want to know how often we end up with the optimal (top ranked) knight\ndepending on which day we stop looking.\n\n## Results  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- knight_sims |>  \n  mutate(result = map_int(stop_after_days, ~optimal_stop(rankings, .x))) |> \n  mutate(is_optimal = result == max(rankings, na.rm = TRUE)) |> \n  group_by(stop_after_days) |> \n  summarise(optimal_stops = sum(is_optimal, na.rm = TRUE),\n            n = n(),\n            optimal_stop_pct = optimal_stops / n,\n            var = sqrt(optimal_stop_pct * (1 - optimal_stop_pct) / n))\n\nresults\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 5\n   stop_after_days optimal_stops     n optimal_stop_pct     var\n             <int>         <int> <int>            <dbl>   <dbl>\n 1               1           533 10000           0.0533 0.00225\n 2               2           846 10000           0.0846 0.00278\n 3               3          1116 10000           0.112  0.00315\n 4               4          1352 10000           0.135  0.00342\n 5               5          1572 10000           0.157  0.00364\n 6               6          1771 10000           0.177  0.00382\n 7               7          1941 10000           0.194  0.00396\n 8               8          2098 10000           0.210  0.00407\n 9               9          2225 10000           0.222  0.00416\n10              10          2360 10000           0.236  0.00425\n# ℹ 90 more rows\n```\n\n\n:::\n:::\n\n\n\nWe can plot the success proportion of bagging the most optimal knight for each\nstopping day. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(results, aes(stop_after_days, optimal_stop_pct)) +\n  geom_line() +\n  geom_ribbon(aes(stop_after_days, ymax = optimal_stop_pct + 1.96 * var, \n                  ymin = optimal_stop_pct - 1.96 * var), \n              alpha = 0.22) +\n  theme_bw() +\n  geom_vline(xintercept = 37, lty = 2, col = 'red') +\n  geom_hline(yintercept = 0.368, lty = 2, col = 'blue') +\n  scale_y_continuous(labels = scales::percent) +\n  labs(title = \"What is the probability of picking the best knight?\",\n       subtitle = \"Based on stopping searching at x days and choosing the next best knight\",\n       x = \"Look for this many days\",\n       y = \"Probability of optimal choice\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nHere is the number of knights we should observe without picking any\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich.max(results$optimal_stop_pct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 37\n```\n\n\n:::\n:::\n\n\n\nAnd here is the probability of choosing the best knight with this strategy\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax(results$optimal_stop_pct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3755\n```\n\n\n:::\n:::\n\n\n\n**So we should let the first 37 knights pass, just like Merlin said. If we do this, \nwe will give ourselves roughly 37% probability of picking the most optimal knight, \nwhich is the best we can do.**\n\n## Mathematical Derivation \n\nSo why 37 days and 37% probability?  \n\nIf we assume we reject the first $r-1$ knights and then choose the next best knight\nwe get to probability \n\n\n$$\nP(r) = \\sum_{j = r}^{n}P(\\text{jth knight is best and you select it})\n$$\n\n\n$$\nP(r) = \\sum_{j = r}^{n}(\\frac{1}{n})(\\frac{r-1}{j-1}) = (\\frac{r-1}{n})\\sum_{j=r}^{n}\\frac{1}{j-1}\n$$\n\nWe want to know which $r$ maximises the probability for large $n$. As $n$ approaches\ninfinity we can let $x$ be the limit of $r/n$ and use $t$ for $j/n$ and $dt$ for\n$1/n$ we get the integral  \n\n$$\nP(x) = x \\int_{x}^{1}(\\frac{1}{t})dt = -x\\log(x)\n$$\n\nIf we take the derivative with respect to x and set the equation to zero we can find the \nvalue of $x$ which maximises this probability:  \n\n$$\n\\text{optimal x} = \\frac{1}{e} = 0.3678...\n$$\n\nand gives the optimal stopping number (for any large n) of $\\frac{n}{e} \\approx 37$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1/exp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.3678794\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n100/exp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 36.78794\n```\n\n\n:::\n:::\n\n\n\n\n# References  \n\nFerguson, T. S. (1989). Who solved the secretary problem?. Statistical science, 4(3), 282-289.  \n\nBrian Christian and Tom Griffiths. 2016. Algorithms to Live By: The Computer Science of Human Decisions. Henry Holt and Co., Inc., USA.\n\nhttps://en.wikipedia.org/wiki/Secretary_problem\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}